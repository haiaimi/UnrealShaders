//#include "Private/Common.ush"
#include "/Engine/Public/Platform.ush"

#ifndef THREADGROUP_SIZE
	#define THREADGROUP_SIZE 4
#endif

Texture2D VelocityField;
Texture2D SrcTexture;
RWTexture2D<half4> RWDstTexture;
float ValueScale;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void Boundary(uint3 GroupId : SV_GroupID,
			    uint3 DispatchThreadId : SV_DispatchThreadID,
			    uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 SrcSize;
	SrcTexture.GetDimensions(SrcSize.x, SrcSize.y);

#if VERTICAL_BOUNDARY
	RWDstTexture[uint2(0, DispatchThreadId.x + 1)] = ValueScale * SrcTexture[uint2(1, DispatchThreadId.x + 1)];
	RWDstTexture[uint2(SrcSize.x - 1, DispatchThreadId.x + 1)] = ValueScale * SrcTexture[uint2(SrcSize.x - 2, DispatchThreadId.x + 1)];
#else
	RWDstTexture[uint2(DispatchThreadId.x + 1, 0)] = (half)ValueScale * SrcTexture[uint2(DispatchThreadId.x + 1, 1)];
	RWDstTexture[uint2(DispatchThreadId.x + 1, SrcSize.y - 1)] = (half)ValueScale * SrcTexture[uint2(DispatchThreadId.x + 1, SrcSize.y - 2)];
#endif
}

float TimeStep;
float Dissipation;
float rdx;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Advect(uint3 GroupId : SV_GroupID,
			uint3 DispatchThreadId : SV_DispatchThreadID,
			uint3 GroupThreadId : SV_GroupThreadID)
{
	float2 FieldSize;
	VelocityField.GetDimensions(FieldSize.x, FieldSize.y);
	half2 CurVelocity = VelocityField[DispatchThreadId.xy + 1].xy;
	half2 PreCoord = half2(DispatchThreadId.xy + 1) - 1.f * TimeStep * CurVelocity;
	//PreCoord = clamp(PreCoord, 0.f, FieldSize);

	uint2 floorCoord = (uint2) clamp(floor(PreCoord), 0.f, (half) FieldSize);
	uint2 roundCoord = floorCoord + uint2(1, 1);
	
	half FracX = frac(PreCoord.x);
	half FracY = frac(PreCoord.y);
	
	RWDstTexture[DispatchThreadId.xy + 1] = Dissipation * half4(lerp(lerp(SrcTexture[floorCoord], SrcTexture[uint2(roundCoord.x, floorCoord.y)], FracX),
											lerp(SrcTexture[uint2(floorCoord.x, roundCoord.y)], SrcTexture[roundCoord], FracX),
											FracY));
}

//void LoadTextureNeighbors(Texture2D<float4> InTexure, uint2 SampleCoord, out float4 Left, out float4 Top, out float4 Right, out float4 Bottom)
//{
//	Left = InTexure[SampleCoord - uint2(1, 0)];
//	Top = InTexure[SampleCoord - uint2(0, 1)];
//	Right = InTexure[SampleCoord + uint2(1, 0)];
//	Bottom = InTexure[SampleCoord + uint2(0, 1)];
//}

void LoadTextureNeighbors(Texture2D InTexure, uint2 SampleCoord, out half4 Left, out half4 Top, out half4 Right, out half4 Bottom)
{
	Left = InTexure[SampleCoord - uint2(1, 0)];
	Top = InTexure[SampleCoord - uint2(0, 1)];
	Right = InTexure[SampleCoord + uint2(1, 0)];
	Bottom = InTexure[SampleCoord + uint2(0, 1)];
}

float Alpha;
float rBeta;
// Jacobi -> Ax=b, 
Texture2D Jacobi_x;
Texture2D Jacobi_b;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Jacobi(uint3 GroupId : SV_GroupID,
			uint3 DispatchThreadId : SV_DispatchThreadID,
			uint3 GroupThreadId : SV_GroupThreadID)
{
	half4 xLeft, xTop, xRight, xBottom;
	LoadTextureNeighbors(Jacobi_x, DispatchThreadId.xy + 1, xLeft, xTop, xRight, xBottom);
	half4 b = Jacobi_b[DispatchThreadId.xy + 1];
	
	RWDstTexture[DispatchThreadId.xy + 1] = (xLeft + xRight + xTop + xBottom + (half) Alpha * b) * (half) rBeta;
}

float4 ForceParam;
int2 ForcePos;
float Radius;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void AddImpluse(uint3 GroupId : SV_GroupID,
				uint3 DispatchThreadId : SV_DispatchThreadID,
				uint3 GroupThreadId : SV_GroupThreadID)
{
	half2 DeltaPos = half2(ForcePos - (int2)DispatchThreadId.xy);
	half c = exp(-dot(DeltaPos, DeltaPos) / (half)Radius);
	RWDstTexture[DispatchThreadId.xy + 1] = SrcTexture[DispatchThreadId.xy + 1] + ForceParam * c;
}

float Halfrdx;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Vorticity(uint3 GroupId : SV_GroupID,
			   uint3 DispatchThreadId : SV_DispatchThreadID,
			   uint3 GroupThreadId : SV_GroupThreadID)
{
	half4 Left, Top, Right, Bottom;
	LoadTextureNeighbors(VelocityField, DispatchThreadId.xy + 1, Left, Top, Right, Bottom);
	RWDstTexture[DispatchThreadId.xy + 1] = Halfrdx * ((Right.y - Left.y) - (Top.x - Bottom.x));
}

Texture2D VorticityField;
float dxScale;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void VorticityForce(uint3 GroupId : SV_GroupID,
			        uint3 DispatchThreadId : SV_DispatchThreadID,
			        uint3 GroupThreadId : SV_GroupThreadID)
{
	half4 Left, Top, Right, Bottom;
	LoadTextureNeighbors(VorticityField, DispatchThreadId.xy + 1, Left, Top, Right, Bottom);
	half4 VC = VorticityField[DispatchThreadId.xy + 1];
	half2 Force = Halfrdx * half2(abs(Top.x) - abs(Bottom.x), abs(Right.x) - abs(Left.x));
	// we can't use normalize() func directly, it is not safe, so we clamp to a min value 
	const half EPSILON = 2.4414e-4;
	half ForceMagSqr = max(EPSILON, dot(Force, Force));
	Force = Force * rsqrt(ForceMagSqr) * (half) dxScale * VC.x * half2(1.f, -1.f);
	RWDstTexture[DispatchThreadId.xy + 1] = VelocityField[DispatchThreadId.xy + 1] + half4(Force * TimeStep, 0.f, 0.f);
}

RWTexture2D<half4> RWDivergence;

// Compute divergence of velocity field
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Divergence(uint3 GroupId : SV_GroupID,
				uint3 DispatchThreadId : SV_DispatchThreadID,
				uint3 GroupThreadId : SV_GroupThreadID)
{
	half4 Left, Top, Right, Bottom;
	LoadTextureNeighbors(SrcTexture, DispatchThreadId.xy + 1, Left, Top, Right, Bottom);
	RWDivergence[DispatchThreadId.xy + 1] = (half) Halfrdx * (Right.x - Left.x - Top.y + Bottom.y);
}

Texture2D PressureField;
RWTexture2D<half4> RWVelocityField;

// Subtract gradient(p) from u, get divergence free velocity field
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void SubstractGradient(uint3 GroupId : SV_GroupID,
					   uint3 DispatchThreadId : SV_DispatchThreadID,
					   uint3 GroupThreadId : SV_GroupThreadID)
{
	half4 Left, Top, Right, Bottom;
	LoadTextureNeighbors(PressureField, DispatchThreadId.xy + 1, Left, Top, Right, Bottom);
	half2 Gradient = half2(Right.x - Left.x, -Top.x + Bottom.x) * (half) Halfrdx;
	RWVelocityField[DispatchThreadId.xy + 1] = VelocityField[DispatchThreadId.xy + 1] - half4(Gradient, 0.f, 0.f);
}