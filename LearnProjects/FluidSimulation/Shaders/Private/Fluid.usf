
Texture2D VelocityField;
SamplerState BilinerSampler;

#ifndef THREADGROUP_SIZE
	#define THREADGROUP_SIZE 4
#endif

Texture2D<float4> SrcTexture;
RWTexture2D<float4> RWDstTexture;
float ValueScale;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void BoundaryCS(uint3 GroupId : SV_GroupID,
			    uint3 DispatchThreadId : SV_DispatchThreadID,
			    uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 SrcSize;
	SrcTexture.GetDimensions(SrcSize.x, SrcSize.y);

#if VERTICAL_BOUNDARY
	RWDstTexture[uint2(0, DispatchThreadId.x + 1)] = ValueScale * SrcTexture[uint2(1, DispatchThreadId.x + 1)];
	RWDstTexture[uint2(SrcSize.x - 1, DispatchThreadId.x + 1)] = ValueScale * SrcTexture[uint2(SrcSize.x - 2, DispatchThreadId.x + 1)];
#else
	RWDstTexture[uint2(DispatchThreadId.x + 1, 0)] = ValueScale * SrcTexture[uint2(DispatchThreadId.x + 1, 1)];
	RWDstTexture[uint2(DispatchThreadId.x + 1, SrcSize.y - 1)] = ValueScale * SrcTexture[uint2(DispatchThreadId.x + 1, SrcSize.y - 2)];
#endif
}

float TimeStep;
float Dissipation;
float rdx;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Advect(uint3 GroupId : SV_GroupID,
			uint3 DispatchThreadId : SV_DispatchThreadID,
			uint3 GroupThreadId : SV_GroupThreadID)
{
	float2 FieldSize;
	SrcTexture.GetDimensions(FieldSize.x, FieldSize.y);
	float2 CurVelocity = SrcTexture[DispatchThreadId.xy + 1].xy;
	float2 PreCoord = float2(DispatchThreadId.xy + 1) - Dissipation * TimeStep * CurVelocity;
	//PreCoord = clamp(PreCoord, 0.f, FieldSize);

	uint2 floorCoord = (uint2)clamp(floor(PreCoord), 0.f, FieldSize);
	uint2 roundCoord = floorCoord;
	
	float FracX = frac(PreCoord.x);
	float FracY = frac(PreCoord.y);
	
	RWDstTexture[DispatchThreadId.xy + 1] = lerp(lerp(SrcTexture[floorCoord].xy, SrcTexture[uint2(roundCoord.x, floorCoord.y)].xy, FracX), 
											lerp(SrcTexture[uint2(floorCoord.x, roundCoord.y)].xy, SrcTexture[roundCoord].xy, FracX), 
											FracY);

}

float Alpha;
float rBeta;
// Jacobi -> Ax=b, 
Texture2D<float4> Jacobi_x;
Texture2D<float4> Jacobi_b;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Jacobi(uint3 GroupId : SV_GroupID,
			uint3 DispatchThreadId : SV_DispatchThreadID,
			uint3 GroupThreadId : SV_GroupThreadID)
{
	float4 xLeft = Jacobi_x[DispatchThreadId.xy - uint2(1, 0)];
	float4 xTop = Jacobi_x[DispatchThreadId.xy - uint2(0, 1)];
	float4 xRight = Jacobi_x[DispatchThreadId.xy + uint2(1, 0)];
	float4 xBottom = Jacobi_x[DispatchThreadId.xy + uint2(0, 1)];
	float4 b = Jacobi_b[DispatchThreadId.xy];
	
	RWDstTexture[DispatchThreadId.xy] = (xLeft + xRight + xTop + xBottom + Alpha * b) * rBeta;
	
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void AddImpluse()
{

}

void VortForce()
{

}

void Diffuse()
{
    
}

float Halfrdx;

// Compute divergence of velocity field
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Divergence(uint3 GroupId : SV_GroupID,
				uint3 DispatchThreadId : SV_DispatchThreadID,
				uint3 GroupThreadId : SV_GroupThreadID)
{
	float4 Left = SrcTexture[DispatchThreadId.xy - uint2(1, 0)];
	float4 Top = SrcTexture[DispatchThreadId.xy - uint2(0, 1)];
	float4 Right = SrcTexture[DispatchThreadId.xy + uint2(1, 0)];
	float4 Bottom = SrcTexture[DispatchThreadId.xy + uint2(0, 1)];
	
	RWDstTexture[DispatchThreadId.xy] = Halfrdx * (Right.x - Left.x + Top.y - Bottom.y);
}

// Solve pressture disturbance
void Pressure()
{

}

// Subtract gradient(p) from u, get divergence free velocity field
void SubstractGradient()
{

}