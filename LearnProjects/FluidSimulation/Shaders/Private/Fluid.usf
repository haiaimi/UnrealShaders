//#include "Private/Common.ush"
#include "/Engine/Public/Platform.ush"

#ifndef THREADGROUP_SIZE
	#define THREADGROUP_SIZE 4
#endif

Texture2D<float4> VelocityField;
Texture2D<float4> SrcTexture;
RWTexture2D<float4> RWDstTexture;
float ValueScale;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void Boundary(uint3 GroupId : SV_GroupID,
			    uint3 DispatchThreadId : SV_DispatchThreadID,
			    uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 SrcSize;
	SrcTexture.GetDimensions(SrcSize.x, SrcSize.y);

#if VERTICAL_BOUNDARY
	RWDstTexture[uint2(0, DispatchThreadId.x + 1)] = ValueScale * SrcTexture[uint2(1, DispatchThreadId.x + 1)];
	RWDstTexture[uint2(SrcSize.x - 1, DispatchThreadId.x + 1)] = ValueScale * SrcTexture[uint2(SrcSize.x - 2, DispatchThreadId.x + 1)];
#else
	RWDstTexture[uint2(DispatchThreadId.x + 1, 0)] = ValueScale * SrcTexture[uint2(DispatchThreadId.x + 1, 1)];
	RWDstTexture[uint2(DispatchThreadId.x + 1, SrcSize.y - 1)] = ValueScale * SrcTexture[uint2(DispatchThreadId.x + 1, SrcSize.y - 2)];
#endif
}

float TimeStep;
float Dissipation;
float rdx;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Advect(uint3 GroupId : SV_GroupID,
			uint3 DispatchThreadId : SV_DispatchThreadID,
			uint3 GroupThreadId : SV_GroupThreadID)
{
	float2 FieldSize;
	VelocityField.GetDimensions(FieldSize.x, FieldSize.y);
	float2 CurVelocity = VelocityField[DispatchThreadId.xy + 1].xy;
	float2 PreCoord = float2(DispatchThreadId.xy + 1) - Dissipation * TimeStep * CurVelocity;
	//PreCoord = clamp(PreCoord, 0.f, FieldSize);

	uint2 floorCoord = (uint2)clamp(floor(PreCoord), 0.f, FieldSize);
	uint2 roundCoord = floorCoord + 1;
	
	float FracX = frac(PreCoord.x);
	float FracY = frac(PreCoord.y);
	
	RWDstTexture[DispatchThreadId.xy + 1] = float4(lerp(lerp(SrcTexture[floorCoord].xy, SrcTexture[uint2(roundCoord.x, floorCoord.y)].xy, FracX),
											lerp(SrcTexture[uint2(floorCoord.x, roundCoord.y)].xy, SrcTexture[roundCoord].xy, FracX),
											FracY), 0.f, 0.f);
}

void LoadTextureNeighbors(Texture2D<float4> InTexure, uint2 SampleCoord, out float4 Left, out float4 Top, out float4 Right, out float4 Bottom)
{
	Left = InTexure[SampleCoord - uint2(1, 0)];
	Top = InTexure[SampleCoord - uint2(0, 1)];
	Right = InTexure[SampleCoord + uint2(1, 0)];
	Bottom = InTexure[SampleCoord + uint2(0, 1)];
}

float Alpha;
float rBeta;
// Jacobi -> Ax=b, 
Texture2D<float4> Jacobi_x;
Texture2D<float4> Jacobi_b;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Jacobi(uint3 GroupId : SV_GroupID,
			uint3 DispatchThreadId : SV_DispatchThreadID,
			uint3 GroupThreadId : SV_GroupThreadID)
{
	float4 xLeft, xTop, xRight, xBottom;
	LoadTextureNeighbors(Jacobi_x, DispatchThreadId.xy + 1, xLeft, xTop, xRight, xBottom);
	float4 b = Jacobi_b[DispatchThreadId.xy + 1];
	
	RWDstTexture[DispatchThreadId.xy + 1] = (xLeft + xRight + xTop + xBottom + Alpha * b) * rBeta;
}

float4 ForceParam;
int2 ForcePos;
float Radius;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void AddImpluse(uint3 GroupId : SV_GroupID,
				uint3 DispatchThreadId : SV_DispatchThreadID,
				uint3 GroupThreadId : SV_GroupThreadID)
{
	float2 DeltaPos = float2(ForcePos - (int2)DispatchThreadId.xy);
	float c = exp(-dot(DeltaPos, DeltaPos) / Radius);
	RWDstTexture[DispatchThreadId.xy + 1] = SrcTexture[DispatchThreadId.xy + 1] + ForceParam * c;
}

void VortForce()
{

}

float Halfrdx;
RWTexture2D<float4> RWDivergence;

// Compute divergence of velocity field
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void Divergence(uint3 GroupId : SV_GroupID,
				uint3 DispatchThreadId : SV_DispatchThreadID,
				uint3 GroupThreadId : SV_GroupThreadID)
{
	float4 Left, Top, Right, Bottom;
	LoadTextureNeighbors(SrcTexture, DispatchThreadId.xy + 1, Left, Top, Right, Bottom);
	RWDivergence[DispatchThreadId.xy + 1] = Halfrdx * (Right.x - Left.x + Top.y - Bottom.y);
}

Texture2D<float4> PressureField;
RWTexture2D<float4> RWVelocityField;

// Subtract gradient(p) from u, get divergence free velocity field
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void SubstractGradient(uint3 GroupId : SV_GroupID,
					   uint3 DispatchThreadId : SV_DispatchThreadID,
					   uint3 GroupThreadId : SV_GroupThreadID)
{
	float4 Left, Top, Right, Bottom;
	LoadTextureNeighbors(PressureField, DispatchThreadId.xy + 1, Left, Top, Right, Bottom);
	float2 Gradient = (Right.x - Left.x + Top.y - Bottom.y) * Halfrdx;
	RWVelocityField[DispatchThreadId.xy + 1] = VelocityField[DispatchThreadId.xy + 1] - float4(Gradient, 0.f, 0.f);

}