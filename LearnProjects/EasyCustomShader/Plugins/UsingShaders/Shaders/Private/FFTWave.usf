#include "/Engine/Public/Platform.ush"

#define PI 3.1415
#define GRAVITY 9.8

int WaveSize;
static float GridLength = 100.f;
float WaveAmplitude;
float3 WindSpeed;

RWTexture2D<float2> RWSpectrum;
RWTexture2D<float2> RWSpectrumConj;

float RandFast(uint2 PixelPos, float Magic = 3571.0)
{
	float2 Random2 = (1.0 / 4320.0) * PixelPos + float2(0.25, 0.0);
	float Random = frac(dot(Random2 * Random2, Magic));
	Random = frac(Random * Random * (2 * Magic));
	return Random;
}

float2 GaussianRandomVariable(uint2 RandSeed)
{
	float x1, x2, w;
	do
	{
		x1 = 2.0f * RandFast(RandSeed) - 1.0f;
		x2 = 2.0f * RandFast(RandSeed + uint2(WaveSize + 1, WaveSize + 1)) - 1.0f;
		w = x1 * x1 + x2 * x2;
		RandSeed += uint2(WaveSize + 1, WaveSize + 1);
	} while (w >= 1.0f);
	
	w = sqrt((-2.0f * log(w)) / w);
	return float2(x1 * w, x2 * w);
}

float PhillipsSpectrum(int n, int m)
{
	float2 k = float2(PI * (2 * n - WaveSize) / GridLength, PI * (2 * m - WaveSize) / GridLength);
	float klength = length(k);
	if (klength < 0.000001f)
		return 0.0f;
	float klength2 = klength * klength;
	float klength4 = klength2 * klength2;
	k = normalize(k);
	
	float kdotw = dot(k, WindSpeed.xy);
	float kdotw2 = kdotw * kdotw * kdotw * kdotw * kdotw * kdotw;
	
	float wlength = length(WindSpeed);
	float L = wlength * wlength / GRAVITY;
	float L2 = L * L;

	float damping = 0.001f;
	float l2 = L2 * damping * damping;
	return 0.1f * WaveAmplitude * exp(-1.0f / (klength2 * L2)) / klength4 * kdotw2 * exp(-klength2 * l2);
}

float2 GetSpectrum(int n, int m)
{
	float2 r = GaussianRandomVariable(uint2(abs(n), abs(m)));
	return r * sqrt(PhillipsSpectrum(n, m) / 2.f);
}

[numthreads(4, 4, 1)]
void PhillipsSpectrumCS(
	int3 GroupId : SV_GroupID,
	int3 GroupThreadID : SV_GroupThreadID,
	int3 DispatchThreadID : SV_DispatchThreadID)
{
	int index = DispatchThreadID.x * (WaveSize + 1) + DispatchThreadID.y;
	RWSpectrum[uint2(index, 0)] = GetSpectrum(DispatchThreadID.y, DispatchThreadID.x);
	float2 Conj = GetSpectrum(-DispatchThreadID.y, -DispatchThreadID.x);
	Conj.y *= -1.0f;
	RWSpectrumConj[uint2(index, 0)] = Conj;
}

float  TimeSeconds;
int StartIndex;
Buffer<float> DispersionTable;
Texture2D<float2> Spectrum;
Texture2D<float2> SpectrumConj;

RWTexture2D<float2> RWHeightBuffer;
RWTexture2D<float4> RWSlopeBuffer;
RWTexture2D<float4> RWDisplacementBuffer;
SamplerState BufferSampler;

Buffer<float>  ButterflyLookupTable;

float2 InitSpectrum(float TimeSeconds, int n, int m)
{
	uint Index = m * (WaveSize + 1) + n;
	float Omegat = DispersionTable[Index] * TimeSeconds;

	float Cos = cos(Omegat);
	float Sin = sin(Omegat);

	uint Width1, Width2, Height;
	Spectrum.GetDimensions(Width1, Height);
	SpectrumConj.GetDimensions(Width2, Height);
	if (Width1 > Index && Width2 > Index)
	{
		float C0a = Spectrum[uint2(Index, 0)].x * Cos - Spectrum[uint2(Index, 0)].y * Sin;
		float C0b = Spectrum[uint2(Index, 0)].x * Sin - Spectrum[uint2(Index, 0)].y * Cos;

		float C1a = SpectrumConj[uint2(Index, 0)].x * Cos - SpectrumConj[uint2(Index, 0)].y * -Sin;
		float C1b = SpectrumConj[uint2(Index, 0)].x * -Sin - SpectrumConj[uint2(Index, 0)].y * Cos;

		return float2(C0a + C1a, C0b + C1b);
	}

	return 0.0f;
}

void PrepareForFFT(float TimeSeconds, int n, int m)
{
	float KX, KY, Len, Lambda = -1.f;
	KY = PI * (2.f * m - WaveSize) / GridLength;
	KX = PI * (2.f * n - WaveSize) / GridLength;
	
	Len = sqrt(KX * KX + KY * KY);
	int Index = m * WaveSize + n;

	float2 C = InitSpectrum(TimeSeconds, n, m);

	RWHeightBuffer[uint2(Index, 1)] = C;

	RWSlopeBuffer[uint2(Index, 1)] = float4(-C.y * KX, C.x * KX, -C.y * KY, C.x * KY);

	if (Len < 0.000001f)
	{
		RWDisplacementBuffer[uint2(Index, 1)] = 0.f;
	}
	else
	{
		RWDisplacementBuffer[uint2(Index, 1)] = float4(-C.y * -(KX / Len), C.x * -(KX / Len), -C.y * -(KY / Len), C.x * -(KY / Len));
	}
}

[numthreads(4, 4, 1)]
void PrepareFFTCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	//TODO
	PrepareForFFT(TimeSeconds, DispatchThreadID.x, DispatchThreadID.y);
}

float4 FFT(float2 w,float4 input1,float4 input2)
{
	input1.x += w.x * input2.x - w.y * input2.y;
	input1.y += w.y * input2.x + w.x * input2.y;
	input1.z += w.x * input2.z - w.y * input2.w;
	input1.w += w.y * input2.z + w.x * input2.w;
	
	return input1;
}

float2 FFT(float2 w, float2 input1, float2 input2)
{
	input1.x += w.x * input2.x - w.y * input2.y;
	input1.y += w.y * input2.x + w.x * input2.y;
	
	return input1;
}

[numthreads(4, 4, 1)]
void PerformFFTCS1(
	uint3 GroupId : SV_GroupID, 
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	int idx = StartIndex % 2;
	int idx1 = (StartIndex + 1) % 2;
	int bftIdx = 4 * (DispatchThreadID.x + StartIndex * WaveSize);
	
	int X = (int) ButterflyLookupTable[bftIdx + 0];
	int Y = (int) ButterflyLookupTable[bftIdx + 1];
	float2 w = float2(ButterflyLookupTable[bftIdx + 2], ButterflyLookupTable[bftIdx + 3]);
	RWHeightBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWHeightBuffer[uint2(X + DispatchThreadID.y * WaveSize, idx1)], RWHeightBuffer[uint2(Y + DispatchThreadID.y * WaveSize, idx1)]);
	RWSlopeBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWSlopeBuffer[uint2(X + DispatchThreadID.y * WaveSize, idx1)], RWSlopeBuffer[uint2(Y + DispatchThreadID.y * WaveSize, idx1)]);
	RWDisplacementBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWDisplacementBuffer[uint2(X + DispatchThreadID.y * WaveSize, idx1)], RWDisplacementBuffer[uint2(Y + DispatchThreadID.y * WaveSize, idx1)]);
}

[numthreads(4, 4, 1)]
void PerformFFTCS2(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	int passes = round(log2(WaveSize)); // equal to log(WaveSize)/log(2)
	int idx = (StartIndex + passes) % 2;
	int idx1 = (StartIndex + passes + 1) % 2;
	int bftIdx = 4 * (DispatchThreadID.y + StartIndex * WaveSize);
	
	int X = (int) ButterflyLookupTable[bftIdx + 0];
	int Y = (int) ButterflyLookupTable[bftIdx + 1];
	float2 w = { ButterflyLookupTable[bftIdx + 2], ButterflyLookupTable[bftIdx + 3] };
	RWHeightBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWHeightBuffer[uint2(DispatchThreadID.x + X * WaveSize, idx1)], RWHeightBuffer[uint2(DispatchThreadID.x + Y * WaveSize, idx1)]);
	RWSlopeBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWSlopeBuffer[uint2(DispatchThreadID.x + X * WaveSize, idx1)], RWSlopeBuffer[uint2(DispatchThreadID.x + Y * WaveSize, idx1)]);
	RWDisplacementBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWDisplacementBuffer[uint2(DispatchThreadID.x + X * WaveSize, idx1)], RWDisplacementBuffer[uint2(DispatchThreadID.x + Y * WaveSize, idx1)]);
}

Texture2D<float2> HeightBuffer;
Texture2D<float4> SlopeBuffer;
Texture2D<float4> DisplacementBuffer;
RWTexture2D<float4> RWOffsetPos;

[numthreads(4, 4, 1)]
void ComputePosAndNormalCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	int Sign;
	static float Signs[2] = { 1.f, -1.f };
	float Lambda = -1.f;
	
	int Index = DispatchThreadID.x * WaveSize + DispatchThreadID.y;
	int Index1 = DispatchThreadID.x * (WaveSize + 1) + DispatchThreadID.y;

	Sign = Signs[(DispatchThreadID.x + DispatchThreadID.y) & 1];
	
	float Width, Height;
	//RWOffsetPos.GetDimensions(Width, Height);
	//RWOffsetPos[Index1].z = HeightBuffer[Index].x * Sign / 500.f;
	
	//RWOffsetPos[Index1].x = DisplacementBuffer[Index].x * Lambda * Sign / 500.f;
	//RWOffsetPos[Index1].y = DisplacementBuffer[Index].y * Lambda * Sign / 500.f;
}