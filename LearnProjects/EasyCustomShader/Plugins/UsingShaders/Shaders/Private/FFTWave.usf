#include "/Engine/Public/Platform.ush"

#define PI 3.1415
#define GRAVITY 9.8

int WaveSize;
float GridLength;
float WaveAmplitude;
float3 WindSpeed;

Buffer<float2> RandomTable;
RWTexture2D<float2> RWSpectrum;
RWTexture2D<float2> RWSpectrumConj;

float RandFast(uint2 PixelPos, float Magic = 3571.0)
{
	float2 Random2 = (1.0 / 4320.0) * PixelPos + float2(0.25, 0.0);
	float Random = frac(dot(Random2 * Random2, Magic));
	Random = frac(Random * Random * (2 * Magic));
	return Random;
}

float2 GaussianRandomVariable(uint2 RandSeed)
{
	float x1, x2, w;
	do
	{
		x1 = 2.0f * RandFast(RandSeed) - 1.0f;
		x2 = 2.0f * RandFast(RandSeed + uint2(WaveSize + 1, WaveSize + 1)) - 1.0f;
		w = x1 * x1 + x2 * x2;
		RandSeed += uint2(WaveSize + 1, WaveSize + 1);
	} while (w >= 1.0f);
	
	w = sqrt((-2.0f * log(w)) / w);
	return float2(x1 * w, x2 * w);
}

float PhillipsSpectrum(int n, int m)
{
	float2 k = float2(PI * (2 * n - WaveSize) / GridLength, PI * (2 * m - WaveSize) / GridLength);
	float klength = length(k);
	if (klength < 0.000001f)
		return 0.0f;
	float klength2 = klength * klength;
	float klength4 = klength2 * klength2;
	k = normalize(k);
	
	float kdotw = dot(k, WindSpeed.xy);
	float kdotw2 = kdotw * kdotw * kdotw * kdotw * kdotw * kdotw;
	
	float wlength = length(WindSpeed);
	float L = wlength * wlength / GRAVITY;
	float L2 = L * L;

	float damping = 0.001f;
	float l2 = L2 * damping * damping;
	return WaveAmplitude * exp(-rcp(klength2 * L2)) / klength4 * kdotw2 * exp(-klength2 * l2);  //compute P_h(k)
}

float2 GetSpectrum(int n, int m)
{
	//get a pair of independent random num(Normal distribution
	uint Index = m * (WaveSize + 1) + n;
	//float2 r = GaussianRandomVariable(uint2(n, m));  //compute in gpu
	float2 r = RandomTable[Index]; //use random table that computed by cpu
	return r * sqrt(PhillipsSpectrum(n, m) / 2.f);
}

[numthreads(4, 4, 1)]
void PhillipsSpectrumCS(
	int3 GroupId : SV_GroupID,
	int3 GroupThreadID : SV_GroupThreadID,
	int3 DispatchThreadID : SV_DispatchThreadID)
{
	int index = DispatchThreadID.x * (WaveSize + 1) + DispatchThreadID.y;
	RWSpectrum[uint2(index, 0)] = GetSpectrum(DispatchThreadID.y, DispatchThreadID.x);   //compute h_0(k)
	float2 Conj = GetSpectrum(-DispatchThreadID.y, -DispatchThreadID.x);
	Conj.y *= -1.0f;  // compute conj of h_0(k)
	RWSpectrumConj[uint2(index, 0)] = Conj;
}

float  TimeSeconds;
int StartIndex;
Buffer<float> DispersionTable;
Texture2D<float2> Spectrum;
Texture2D<float2> SpectrumConj;

RWTexture2D<float2> RWHeightBuffer;
RWTexture2D<float4> RWSlopeBuffer;
RWTexture2D<float4> RWDisplacementBuffer;
SamplerState BufferSampler;

Buffer<float>  ButterflyLookupTable;

float2 InitSpectrum(float TimeSeconds, int n, int m)
{
	uint Index = m * (WaveSize + 1) + n;
	float Omegat = DispersionTable[Index] * TimeSeconds;

	float Cos = cos(Omegat);
	float Sin = sin(Omegat);

	uint Width1, Width2, Height;
	Spectrum.GetDimensions(Width1, Height);
	SpectrumConj.GetDimensions(Width2, Height);
	if (Width1 > Index && Width2 > Index)
	{
		//Compute the Phullips spectrum h(k,t),because of 'Euler's identity'-> e^(ix)=cosx + i*sinx
		//Make h=(a,i*b), we can get: (a, i*b)*(cosx, i*sinx) = (a*cosx-b*sinx, a*sinx+b*cosx)
		float C0a = Spectrum[uint2(Index, 0)].x * Cos - Spectrum[uint2(Index, 0)].y * Sin;
		float C0b = Spectrum[uint2(Index, 0)].x * Sin + Spectrum[uint2(Index, 0)].y * Cos;

		float C1a = SpectrumConj[uint2(Index, 0)].x * Cos - SpectrumConj[uint2(Index, 0)].y * -Sin;
		float C1b = SpectrumConj[uint2(Index, 0)].x * -Sin + SpectrumConj[uint2(Index, 0)].y * Cos;
		//            real part    imaginary part 
		return float2(C0a + C1a,    C0b + C1b);
	}

	return 0.0f;
}

void PrepareForFFT(float TimeSeconds, int n, int m)
{
	float KX, KY, Len, Lambda = -1.f;
	KY = PI * (2.f * m - WaveSize) / GridLength;
	KX = PI * (2.f * n - WaveSize) / GridLength;
	
	Len = sqrt(KX * KX + KY * KY);
	int Index = m * WaveSize + n;
	
	float2 C = InitSpectrum(TimeSeconds, n, m);

	// Get the height
	RWHeightBuffer[uint2(Index, 1)] = C;

	// Compute the slope for normal, i*(KX, KY)*C.  ---------ddx-------      ---------ddy------- 
	//                                               real    imaginary        real    imaginary
	RWSlopeBuffer[uint2(Index, 1)] =         float4(-C.y * KX, C.x * KX,    -C.y * KY, C.x * KY);

	if (Len < 0.000001f)
	{
		RWDisplacementBuffer[uint2(Index, 1)] = 0.f;
	}
	else
	{
		RWDisplacementBuffer[uint2(Index, 1)] = float4(-C.y * -(KX / Len), C.x * -(KX / Len), -C.y * -(KY / Len), C.x * -(KY / Len));
	}
}

[numthreads(4, 4, 1)]
void PrepareFFTCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	//TODO
	PrepareForFFT(TimeSeconds, DispatchThreadID.x, DispatchThreadID.y);
}

float4 FFT(float2 w,float4 input1,float4 input2)
{
	input1.x += w.x * input2.x - w.y * input2.y;
	input1.y += w.y * input2.x + w.x * input2.y;
	input1.z += w.x * input2.z - w.y * input2.w;
	input1.w += w.y * input2.z + w.x * input2.w;
	
	return input1;
}

float2 FFT(float2 w, float2 input1, float2 input2)
{
	input1.x += w.x * input2.x - w.y * input2.y;
	input1.y += w.y * input2.x + w.x * input2.y;
	
	return input1;
}

[numthreads(4, 4, 1)]
void PerformFFTCS1(
	uint3 GroupId : SV_GroupID, 
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	int idx = StartIndex % 2;
	int idx1 = (StartIndex + 1) % 2;
	int bftIdx = 4 * (DispatchThreadID.x + StartIndex * WaveSize);
	
	int X = (int) ButterflyLookupTable[bftIdx + 0];
	int Y = (int) ButterflyLookupTable[bftIdx + 1];
	float2 w = float2(ButterflyLookupTable[bftIdx + 2], ButterflyLookupTable[bftIdx + 3]);
	RWHeightBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWHeightBuffer[uint2(X + DispatchThreadID.y * WaveSize, idx1)], RWHeightBuffer[uint2(Y + DispatchThreadID.y * WaveSize, idx1)]);
	RWSlopeBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWSlopeBuffer[uint2(X + DispatchThreadID.y * WaveSize, idx1)], RWSlopeBuffer[uint2(Y + DispatchThreadID.y * WaveSize, idx1)]);
	RWDisplacementBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWDisplacementBuffer[uint2(X + DispatchThreadID.y * WaveSize, idx1)], RWDisplacementBuffer[uint2(Y + DispatchThreadID.y * WaveSize, idx1)]);

}

[numthreads(4, 4, 1)]
void PerformFFTCS2(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	int passes = round(log2(WaveSize)); // equal to log(WaveSize)/log(2)
	int idx = (StartIndex + passes) % 2;
	int idx1 = (StartIndex + passes + 1) % 2;
	int bftIdx = 4 * (DispatchThreadID.y + StartIndex * WaveSize);
	
	int X = (int) ButterflyLookupTable[bftIdx + 0];
	int Y = (int) ButterflyLookupTable[bftIdx + 1];
	float2 w = { ButterflyLookupTable[bftIdx + 2], ButterflyLookupTable[bftIdx + 3] };
	RWHeightBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWHeightBuffer[uint2(DispatchThreadID.x + X * WaveSize, idx1)], RWHeightBuffer[uint2(DispatchThreadID.x + Y * WaveSize, idx1)]);
	RWSlopeBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWSlopeBuffer[uint2(DispatchThreadID.x + X * WaveSize, idx1)], RWSlopeBuffer[uint2(DispatchThreadID.x + Y * WaveSize, idx1)]);
	RWDisplacementBuffer[uint2(DispatchThreadID.x + DispatchThreadID.y * WaveSize, idx)] = FFT(w, RWDisplacementBuffer[uint2(DispatchThreadID.x + X * WaveSize, idx1)], RWDisplacementBuffer[uint2(DispatchThreadID.x + Y * WaveSize, idx1)]);
}

SamplerState TextureSampler;
Texture2D<float2> HeightBuffer;
Texture2D<float4> SlopeBuffer;
Texture2D<float4> DisplacementBuffer;

void ComputePosAndNormalVS(
	in float4 InPosition : ATTRIBUTE0,
	in float2 UV : ATTRIBUTE1,
	out float2 OutUV : TEXCOORD0,
	out float4 OutPosition : SV_POSITION
	)
{
	OutPosition = InPosition;
	OutUV = UV;
}

static float Signs[2] = { 1.f, -1.f };

void GetPosOffsetAndNormal(int2 Coord, int Size, out float3 PosOffset, out float3 Normal)
{
    Coord.x -= (Coord.x / Size) * Coord.x; 
    Coord.y -= (Coord.y / Size) * Coord.y; 
	int Index = Coord.x * Size + Coord.y;
	int Sign = Signs[(Coord.x + Coord.y) & 1];
    float Lambda = -1.f;

	PosOffset = float3(DisplacementBuffer[int2(Index, 1)].z * Lambda * Sign, DisplacementBuffer[int2(Index, 1)].x * Lambda * Sign, HeightBuffer[int2(Index, 1)].x * Sign);
	Normal = float3(-SlopeBuffer[int2(Index, 1)].z * Sign, -SlopeBuffer[int2(Index, 1)].x * Sign, 1.f);
	Normal /= length(Normal);
	//Normal = normalize(float3(0.f, 0.f, 1.f));
}

void ComputePosAndNormalPS(
	in float2 UV : TEXCOORD0,
	out float4 OutPosOffset : SV_Target0,
	out float4 OutNormal : SV_Target1
)
{
	int Sign;
	int Width, Height;
	HeightBuffer.GetDimensions(Width, Height);
	int Size = sqrt(Width);
	float CoordX = Size * UV.x;
	int PointX = floor(CoordX);
	float LerpAlphaX = frac(CoordX);
	[branch]
	if (PointX == Size)
	{
		PointX -= 1;
		LerpAlphaX = 1.f;
	}
	float CoordY = Size * UV.y;
	int PointY = floor(CoordY);
	float LerpAlphaY = frac(CoordY);
	[branch]
	if (PointY == Size)
	{
		PointY -= 1;
		LerpAlphaY = 1.f;
	}
	
	int RightPoint = PointX + sign(LerpAlphaX);
	int DownPoint = PointY + sign(LerpAlphaY);
	bool bInBorderRight = (RightPoint == Size);
	bool bInBorderDown = (DownPoint == Size);
	float3 TopLeftPos, TopRightPos, DownLeftPos, DownRightPos;
	float3 TopLeftNormal, TopRightNormal, DownLeftNormal, DownRightNormal;
	GetPosOffsetAndNormal(int2(PointX, PointY), Size, TopLeftPos, TopLeftNormal);
	GetPosOffsetAndNormal(int2(RightPoint, PointY), Size, TopRightPos, TopRightNormal);
	GetPosOffsetAndNormal(int2(PointX, DownPoint), Size, DownLeftPos, DownLeftNormal);
	GetPosOffsetAndNormal(int2(RightPoint, DownPoint), Size, DownRightPos, DownRightNormal);
	//Bilinear lerp
	OutPosOffset = float4(lerp(lerp(TopLeftPos, TopRightPos, LerpAlphaX), lerp(DownLeftPos, DownRightPos, LerpAlphaX), LerpAlphaY), 1.f);
	OutNormal = float4(lerp(lerp(TopLeftNormal, TopRightNormal, LerpAlphaX), lerp(DownLeftNormal, DownRightNormal, LerpAlphaX), LerpAlphaY), 1.f);
}