#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Random.ush"

#define PI 3.1415
int WaveSize;
float3 WindDirection;

float2 GaussianRandomVariable(uint2 RandSeed)
{
	float x1, x2, w;
	do
	{
		x1 = 2.0f * RandFast(RandSeed) - 1.0f;
		x2 = 2.0f * RandFast(RandSeed + uint2(WaveSize, WaveSize)) - 1.0f;
		w = x1 * x1 + x2 * x2;
	} while (w >= 1.0f);
	
	w = sqrt((-2.0f * log(w)) / w);
	return float2(x1 * w, x2 * w);
}

float PhillipsSpectrum(int n, int m)
{
	float2 k = float2(PI * (2 * n - WaveSize) / WaveSize, PI * (2 * m - WaveSize) / WaveSize);
	float klength = length(k);
	if (k < 0.000001f)
		return 0.0f;
	float klength2 = klength * klength;
	float klength4 = klength2 * klength2;
	k = normalize(k);
	
	float kdotw = dot(k, WindDirection.xy);

}

[numthreads(8, 8, 8)]
void PhillipsSpectrumCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	
}

float  TimeSeconds;
int StartIndex;
RWTexture2D<float2> HeightBuffer;
RWTexture2D<float4> SlopeBuffer;
RWTexture2D<float4> DisplacementBuffer;
float4 ButterflyLookupTable[];

float4 FFT(float2 w,float4 input1,float4 input2)
{
	input1.x += w.x * input2.x - w.y * input2.y;
	input1.y += w.y * input2.x + w.x * input2.y;
	input1.z += w.x * input2.z - w.y * input2.w;
	input1.w += w.y * input2.z + w.x * input2.w;
	
	return input1;
}

float2 FFT(float2 w, float2 input1, float2 input2)
{
	input1.x += w.x * input2.x - w.y * input2.y;
	input1.y += w.y * input2.x + w.x * input2.y;
	
	return input1;
}

[numthreads(8, 8, 8)]
void PerformFFTCS1(
	uint3 GroupId : SV_GroupID, 
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	int idx = DispatchThreadID.z % 2;
	int idx1 = (DispatchThreadID.z + 1) % 2;
	int bftIdx = 4 * (DispatchThreadID.x + DispatchThreadID.z * WaveSize);
	
	int X = (int)ButterflyLookupTable[bftIdx + 0];
	int Y = (int)ButterflyLookupTable[bftIdx + 1];
	float2 w = { ButterflyLookupTable[bftIdx + 2], ButterflyLookupTable[bftIdx + 3] };
	HeightBuffer[idx][DispatchThreadID.x + DispatchThreadID.y * WaveSize] = FFT(w, HeightBuffer[uint2(idx1, X + DispatchThreadID.y * WaveSize)], HeightBuffer[uint2(idx1, Y + DispatchThreadID.y * WaveSize)]);
	SlopeBuffer[idx][DispatchThreadID.x + DispatchThreadID.y * WaveSize] = FFT(w, HeightBuffer[uint2(idx1, X + DispatchThreadID.y * WaveSize)], HeightBuffer[uint2(idx1, Y + DispatchThreadID.y * WaveSize)]);
	DisplacementBuffer[idx][DispatchThreadID.x + DispatchThreadID.y * WaveSize] = FFT(w, DisplacementBuffer[uint2(idx1, X + DispatchThreadID.y * WaveSize)], DisplacementBuffer[uint2(idx1, Y + DispatchThreadID.y * WaveSize)]);
}

[numthreads(8, 8, 8)]
void PerformFFTCS2(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadID : SV_GroupThreadID,
	uint3 DispatchThreadID : SV_DispatchThreadID)
{
	int passes = log2(WaveSize); // equal to log(WaveSize)/log(2)
	int idx = (DispatchThreadID.z + passes) % 2;
	int idx1 = (DispatchThreadID.z + passes + 1) % 2;
	int bftIdx = 4 * (DispatchThreadID.y + DispatchThreadID.z * WaveSize);
	
	int X = (int) ButterflyLookupTable[bftIdx + 0];
	int Y = (int) ButterflyLookupTable[bftIdx + 1];
	float2 w = { ButterflyLookupTable[bftIdx + 2], ButterflyLookupTable[bftIdx + 3] };
	HeightBuffer[idx][DispatchThreadID.x + DispatchThreadID.y * WaveSize] = FFT(w, HeightBuffer[uint2(idx1,  DispatchThreadID.x + X * WaveSize)], HeightBuffer[uint2(idx1, DispatchThreadID.x + Y * WaveSize)]);
	SlopeBuffer[idx][DispatchThreadID.x + DispatchThreadID.y * WaveSize] = FFT(w, HeightBuffer[uint2(idx1, DispatchThreadID.x + X * WaveSize)], HeightBuffer[uint2(idx1, DispatchThreadID.x + Y * WaveSize)]);
	DisplacementBuffer[idx][DispatchThreadID.x + DispatchThreadID.y * WaveSize] = FFT(w, DisplacementBuffer[uint2(idx1, DispatchThreadID.x + X * WaveSize)], DisplacementBuffer[uint2(idx1, DispatchThreadID.x + Y * WaveSize)]);
}